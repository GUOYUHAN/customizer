{
  "fragment": {
    "alphamap_fragment": [
      "if (useHighLight == 1) {\n",
      "  #if defined( ALPHATEST )\n",
      "    diffuseColor.rgb = highLightColor.rgb;\n",
      "    diffuseColor.a = highLightAlpha;\n",
      "  #else\n",
      "    diffuseColor.rgb = highLightAlpha * highLightColor.rgb + (1.0 - highLightAlpha) * diffuseColor.rgb;\n",
      "  #endif\n",
      "} else {\n",
      "  #if defined( ALPHATEST )\n",
      "    diffuseColor.a = 0.0;\n",
      "  #elif defined( USE_ALPHAMAP )\n",
      "    diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n",
      "  #else\n",
      "#include <alphamap_fragment>\n",
      "  #endif\n",
      "}\n"
    ],
    "alphatest_fragment": [
      "#ifdef ALPHATEST\n",
      "  // if ( diffuseColor.a < ALPHATEST ) discard;\n",
      "#endif\n"
    ],
    "normal_fragment_maps": [
      "#ifdef USE_NORMALMAP\n",
      "  #ifdef OBJECTSPACE_NORMALMAP\n",
      "    normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n",
      "    #ifdef FLIP_SIDED\n",
      "      normal = - normal;\n",
      "    #endif\n",
      "    #ifdef DOUBLE_SIDED\n",
      "      normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n",
      "    #endif\n",
      "    normal = normalize( normalMatrix * normal );\n",
      "  #else // tangent-space normal map\n",
      "    #if defined( USE_BUMPMAP )\n",
      "      normal = perturbNormal2Arb(-vViewPosition, perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() ));\n",
      "      //normal = perturbNormalArb(-vViewPosition, perturbNormal2Arb( -vViewPosition, normal ), dHdxy_fwd());\n",
      "    #else\n",
      "      normal = perturbNormal2Arb( -vViewPosition, normal );\n",
      "    #endif\n",
      "  #endif\n",
      "#elif defined( USE_BUMPMAP )\n",
      "  normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n",
      "#endif\n"
    ],
    "normalmap_pars_fragment": [
      "#ifdef USE_NORMALMAP\n",
      "uniform sampler2D normalMap;\n",
      "uniform vec2 normalScale;\n",
      "#ifdef OBJECTSPACE_NORMALMAP\n",
      " uniform mat3 normalMatrix;\n",
      "#else\n",
      "  // Per-Pixel Tangent Space Normal Mapping\n",
      "  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n",
      "  vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n",
      "    // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n",
      "    vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n",
      "    vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n",
      "    vec2 st0 = dFdx( vUv.st );\n",
      "    vec2 st1 = dFdy( vUv.st );\n",
      "\n",
      "    float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n",
      "\n",
      "    vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n",
      "    vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n",
      "    vec3 N = normalize( surf_norm );\n",
      "    mat3 tsn = mat3( S, T, N );\n",
      "\n",
      "    vec3 mapN = texture2D( normalMap, normalRepeat * vUv ).xyz * 2.0 - 1.0;\n",
      "\n",
      "    mapN.xy *= normalScale;\n",
      "    mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n",
      "\n",
      "    return normalize( tsn * mapN );\n",
      "  }\n",
      "#endif\n",
      "#endif\n"
    ]
  },
  "vertex": {}
}